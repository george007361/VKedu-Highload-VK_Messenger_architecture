# VK Messenger
> Семестровое домашнее задание по курсу Highload. Технопарк ВК МГТУ им. Баумана, весна 2023. Илларионов Георгий WEB-31 \
> [Методические указания](https://github.com/init/highload/blob/main/homework_architecture.md)

## 1 Тема 
**VK Messenger** - сервис для обмена сообщениями между пользователями. Включает такие функции как: обмен текстовыми сообщениями, стикерами, голосовыми сообщениями и вложениями в личных и групповых чатах. Также имеется возможность совершать голосовые и видео- звонки и создавать конференции.

### MVP
Ключевой функционал мессенжера- обмен сообщениями в реальном времени.
1. Профиль пользователя 
2. Создание, удаление личных чатов
3. Отправка, редактирование, удаление сообщений
4. Возможность прикреплять вложения к сообщениям.
5. Возможность отправлять голосовые сообщения
6. Поиск пользователей
7. Функционал Multilogin не предусмотрен

### Целевая аудитория
- Суммарная аудитория 100 млн пользователей [^1] [^2]
- Месячная аудитория 76,9 млн пользователей [^1] [^2]
- Дневная аудитория 49,4 млн пользователей [^1] [^2]
- 15 млрд сообщений в день в среднем [^3]
- 33 млн пользователей в месяц пользуются голосовыми сообщениями [^3]
- Распределение по странам (Подавляющее большинство из стран СНГ): [^4]

| Страна | Посетителей в месяц |
| ------ | ------------------- |

|           | %    | Млн. чел. |
| --------- | ---- | --------- |
| Россия    | 65,7 | 50,5      |
| Украина   | 18,3 | 14,1      |
| Норвегия  | 5,6  | 4,3       |
| Беларусь  | 2,5  | 1,9       |
| Польша    | 1,7  | 1,3       |
| Казахстан | 1,1  | 0,8       |
| Остальные | 5    | 3,8       |

## 2 Расчёт нагрузки
### Продуктовые метрики
- Месячная аудитория - 76,9 млн. пользователей [^1] [^2] 
- Дневная аудитория - 49,4 млн. пользователей [^1] [^2]
- Ежедневно пользователи отправляют около 15 миллиардов сообщений [^3]
- Ежедневно пользователи создают более 3 миллионов чатов [^5]
- 33 млн пользователей ежемесячно используют голосовые сообщения [^1]

### Среднее количество действий пользователя по типам в день
1. Регистрация новых пользователей в день: *0,078 млн. чел. в день*
   > Рост за месяц составил 2,4% [^1] [^2] \
   > D - прирост пользователей за день, Х - Число пользователей в новом месяце, Y - Число пользователей в старом месяце \
   > Y = X * (100% + 2,4%) = X * 1,024 \
   > X = Y / 1,024 = 97,66 млн. чел. \
   > D = (Y - X) / 30 = 2,34 млн. чел. в мес. / 30 дней = 0,078 млн. чел. в день
   
   **RPS на регистрацию:** *0,9*
   > 0,078 * 1000000 / (24 * 60 * 60) = 0,9 
2. Авторизация пользователей в день: *15 раз*
   > Будем считать, что при посещении сервиса пользователь авторизуется раз в 3 месяца, получает куку и далее использует её. Получается, что в месяц выполняется 76,9 млн. / 3 = 26,6 млн. запросов авторизации или 0,85 млн. запросов авторизации в сутки

   **RPS на авторизацию:** *10*
   >  0,85 млн / (24 * 60 * 60) = 10
3. Создание диалогов в день: *0,06 раз*
   > В среднем за сутки создаётся 3 млн чатов [^5], получается, что каждый пользователь в день создаёт  3 / 49,4 = 0,06 чатов в день
   
   **RPS на создание чатов:** *35*
   > 3 * 1000000 / (24 * 60 * 60) = 34,7 = 35

4. Получение списка диалогов: *15 раз*
   > Полагаем, что запрос на получение списка диалогов происходит при каждом посещении мессенджера. \
   > Пользователь заходит в мессенджеры в среднем 25 раз в день[^7], а доля ВК на рынке мессенджеров составляет 62% [^8], то есть на ВК по грубой оценке приходится около **15 посещений в сутки от одного пользователя** и при каждом посещении требуется получить список диалогов.

   **RPS на получение списка диалогов:** *8576*
   > 15 * 49.4 млн / (24 * 60 * 60) = 8576 
5. Удаление диалогов в день: предположим, что оно *пренебрежительно мало*
6. Отправка новых сообщений в день: *272 текстовых и 26 голосовых сообщения*
   > По статистике голосовыми сообщениями пользуется 33 млн пользователей [^1] из 76,9 млн [^1] ежемесячно. \
   > Тогда доля пользователей, использующих голосовые сообщения, есть 33 / 76,9 = 0,43, а не использующих ГС - 0,57. \
   > Будем считать, что такое соотношение сохраняется ежедневно и каждый месяц. \
   > Также предположим, что пользователи использующие ГС, отправляют его в 25% случаях, а в остальных 75% используют текстовые сообщения. \
   > Пользователи, не использующие ГС, оправляют текстовые в 100% случаев. \
   > Используя данные выше, определим вероятность того, что новое отправленное сообщение  \
   > а) не является голосовым: 1 * 0,57 + 0,8 * 0,43 = 0,914 \
   > б) является голосовым: 0 * 0,57 + 0,2 * 0,43 = 0,086 \
   > Проверка: Сумма (а) и (б) = 1 - верно.  \
   > Ежедневно пользователи отправляют около 15 млрд сообщений [^3], тогда каждый пользователь в среднем за сутки отправляет: \
   > 0,914 * 15 млрд / 49,4 млн = 277 не голосовых сообщения \
   > 0,086 * 15 млрд / 49,4 млн = 26 голосовых сообщения

   **RPS на отправку текстовых сообщений:** *158 680*
   > 0,914 * 15 млрд / (24 * 60 * 60) = 158 680
   
   **RPS на отправку голосовых сообщений:** *14 930*
   > 0,086 * 15 млрд / (24 * 60 * 60) = 14 930
7.  Загрузка новых вложений в день: *6*
    > Предположим что только 2% текстовых сообщений имеют вложения. Тогда в день пользователь в среднем загружает 272 * 0.02 = 6 вложений

    **RPS на загрузку вложений**: *3 430*
    > 6 * 49,4 * 1000000 / (24 * 60 * 60) = 3 430
8. Изменение отправленных сообщений в день: *28 сообщений*
   > Предположим, что в каждом десятом текстовом сообщении пользователь делает ошибку и исправляет его, тогда 10% * 277 = 28 редактирования в сутки на одного пользователя
   
   **RPS на изменение сообщения:** *16009*
   > 28 * 49,4 млн / (24 * 60 * 60) = 16009
9. Удаление отправленных сообщений в день: *3 сообщения*
   > Будем считать, что только 1% сообщений удаляется, тогда (277 + 26) * 1% = 3 сообщения удаляет пользователь в день.
   
   **RPS на удаление сообщений:** *1715*
   > 3 * 49,4 * 1000000 / (24 * 60 * 60) = 1715
10. Получение сообщений в диалоге: *110 раз*
    > Примем количество активных диалогов равным 5 \
    > Используем предположения из п.4 (количество посещений в сутки 15), получаем: 15 раз в день * 5 активных диалогов = 80 запросов на получение сообщений в, когда пользователь заходит в мессенжер. При условии прочтения только последних сообщений (без пролистывания к более старым) это соответствует 80 * 10 = 800 сообщениям. \
    > Из них, согласно п.6, доля голосовых сообщений составляет 0.086, тогда: 0.086 * 800 = 69 голосовых сообщений, 69 запросов на получение голосового сообщения. \
    > Из них, согласно п.4, доля текстовых сообщений составляет 0.914, а по п.7 2% сообщений имеют вложения, тогда: 2% * 0.914 * 800 = 15 имеют вложения, 15 запросов на получение вложений. \
    > Также, пользователь читает все новые сообщения: 272 текстовых и 26 голосовых (суммарно 298, при условии 5 активных чатов - 60 запросов на получение сообщений) согласно п.  \
    > Из них, согласно п.6, получаем: 0.086 * 298 = 26 голосовых сообщений, 26 запросов на получение голосового сообщения \
    > Из них, согласно п.6 и п.7, получаем: 2% * 0.914 * 298 = 6 имеют вложения, 6 запросов на получение вложений

    **RPS на получение сообщений в диалоге**: *80 046*
    > (80 + 60) * 49,4 млн / (24 * 60 * 60) = 80 046

    **RPS на получение голосовых сообщений**: *54 317*
    > (69 + 26) * 49,4 млн / (24 * 60 * 60) = 54 317

    **RPS на получение вложений**: *12 006*
    > (15 + 6) * 49,4 млн / (24 * 60 * 60) = 12 006
11. Поиск пользователей за день: *0,06 раз*
    > Будем считать, что необходимость искать пользователя возникает при создании чата. Используем п.3: 0,06 раз за день пользователь создает диалог/чат, следовательно, столько же раз и выполняется поиск.  
    
    **RPS на поиск пользователей:** *35*
12. Авторизация по сессии 
    > Авторизация требуется для каждого запроса

### Сводная таблица RPS по типовым действиям
|   №   | Действие                             |  Тип   | RPS     |
| :---: | ------------------------------------ | :----: | :------ |
|   1   | Регистрация                          | Запись | 1       |
|   2   | Авторизация по данным уч. записи     | Запись | 10      |
|   3   | Авторизация по сессии                | Чтение | 283 467 |
|   4   | Создание чата                        | Запись | 35      |
|   5   | Удаление чата                        | Запись | 0       |
|   6   | Получение списка чатов  пользователя | Чтение | 8 576   |
|   7   | Отправка текстового сообщения        | Запись | 158 680 |
|   8   | Отправка голосового сообщения        | Запись | 14 930  |
|   9   | Отправка вложений в сообщения        | Запись | 3 430   |
|  10   | Изменение сообщения                  | Запись | 16 009  |
|  11   | Удаление сообщений                   | Запись | 1 715   |
|  12   | Получение списка сообщений           | Чтение | 80 046  |
|  13   | Получение голосовых сообщений        | Чтение | 54 317  |
|  14   | Получение вложений                   | Чтение | 12 006  |
|  15   | Поиск пользователя                   | Чтение | 35      |

**Суммарное RPS на чтение и на запись**
- На чтение: 515 476 RPS
- На запись: 194 810 RPS

## Логическая схема базы данных
![схема бд](/imgs/db_scheme.png)

## Технические метрики
### Средний размер хранилища
> Предположим, что:
> 1. Средний размер аватарки пользователя: **2 мб**
> 2. Имя и фамилия:
>    В среднем: **14 байт**
>       > 7 букв на имя + 7 букв на фамилию [^6] = 14 символов = 14 байт
> 3. Информация о себе:
>    В среднем: **40 байт**
>       > 40 символов = 40 байт
>    Максимальная: **256 байт**
> 4. Длина email:
>       Средняя: **25 байт** \
>       Максимальная: **256 байт**
> 5. Средний размер вложенной в сообщение картинки: **2 мб**
> 6. У пользователя в среднем **2 устройства**
> 7. Расчёт выполняем за **3 года**
> 8. [Продуктовые метрики](#Продуктовые-метрики)
> 9. [Схема базы данных](#Логическая-схема-базы-данных)
> 10. Средняя длина сообщения: **100 байт**
> 11. Среднее количество чатов у пользователя: **40**
> 12. Среднее количество вложений в сообщении с вложениями: **1**

1. Аватарки пользователей: **190,73 Тб**
   > 100 млн пользователей * 2 мб = 190,73 Тб
2. Голосовые сообщения: **315 740,7 Тб**
   > 15 млрд сообщений в сутки, доля голосовых 0,086 \
   > 0,086 * 15 млрд = 1,29 млрд сообщений в день \
   > Получаем: 1,29 млрд * 365 * 3 = 1412,6 млрд сообщений за 3 года \
   > Принимаем среднюю длину голосового сообщения за 10 секунд, кодирование OGG (192 кбит / с), откуда вес одного ГС 1920 кбит \
   > Итого 1412,6 млрд * 192 кбит = 315 740,7 Тб
3. Вложения в сообщениях: **626 564 Тб**
   > 2% текстовых сообщений имеют вложения, 15 млрд сообщений в сутки \
   > Тогда объем хранилища вложений составит: \
   > 15 млрд * 365 * 3 * 2% * 2 мб = 626 564 Тб 
4. Данные авторизации (cookies): **11 Гб**
   > Поля занимают: \
   > `id` 2 байта;  \
   > `user_id` 2 байта, \
   > `cookie` 16 байт, \
   > `expires` 8 байт. 
   
   77 млн чел * 2 устройства * (2 + 2 + 64 + 8) байт = 11 Гб
5. Данные пользователя (users): **20,95 Гб**
   > Поля занимают:
   > `id` - 2 байт \
   > `first_name` - 7 байт \
   > `last_name` - 7 байт \
   > `email` - 25 байт \
   > `passwd_hash` - 128 байт \
   > `about` - 40 байт \
   > `avatar_uuid` - 16 байт

   100 млн чел * (2 + 7 + 7 + 25 + 128 + 40 + 16) байт = 20,95 Гб
6. Данные чатов (chats)
   > Поля занимают: \
   > `id` - 2 байт \
   > `user_1_id` - 2 байт \
   > `user_2_id` - 2 байт

   100 млн чел * 40 чатов * (2 + 2 + 2) байт = **22,38 Гб**
7. Данные сообщений (messages)
   > Поля занимают: \
   > `id` - 8 байт \
   > `author_id` - 2 байт \
   > `chat_id` - 2 байт \
   > `create_date` - 8 байт \
   > `edit_date` - 8 байт \
   > `text_content` - 100 байт в среднем (0 если это голосовое сообщение) \
   > `voice_content_uuid` - 16 байт (0 если текстовое) \
   > `attachment_uuids` - 16 байт (16 * n, где n - число вложений) \

   Только текстовые: \
      13,71 млрд * (8 + 2 + 2 + 8 + 8 + 100) байт = **1634 Гб / день** \
   Голосовые: \
      1,29 млрд * (8 + 2 + 2 + 8 + 8 + 16) байт = **53 Гб / день** \
   Текстовые с вложениями: \
      0,28 млрд * (8 + 2 + 2 + 8 + 8 + 100 + 16) байт = **38 Гб / день** \

   Итого: **1725 Гб / день**
   
   Рассчитаем размер сообщений за 3 года: **1 845 Тб**
   > Пренебрегаем ростом аудитории и считаем частоту отправки постоянной: \
   > 1725 Гб / день * 365 * 3 = 1 845 Тб

#### Cводная таблица размера элемента в хранилище по типам
| Название             | Размер    |
| -------------------- | --------- |
| Аватарка             | 2 мб      |
| Голосовое сообщение  | 1920 кбит |
| Вложение в сообщении | 2 мб      |
| Сессия               | 76 байт   |
| Пользователь         | 225 байт  |
| Чат                  | 6 байт    |
| Сообщение            | 144 байт  |

#### Cводная таблица размера хранилища по типам
| Название              | Сущность | Размер       |
| --------------------- | -------- | ------------ |
| Аватарки              | Файл     | 190,73 Тб    |
| Голосовые сообщения   | Файл     | 315 740,7 Тб |
| Вложения в сообщениях | Файл     | 626 564 Тб   |
| Сессии                | БД       | 11 Гб        |
| Пользователи          | БД       | 20,95 Гб     |
| Чаты                  | БД       | 22,38 Гб     |
| Сообщения             | БД       | 1 845 Тб     |

### Сетевой трафик 
> Данные:
> 1. [Сводная таблица RPS по типовым действиям](#Сводная-таблица-RPS-по-типовым-действиям)
> 2. [Cводная таблица размера элемента в хранилище по типам](#Cводная-таблица-размера-элемента-в-хранилище-по-типам)
> 3. [Размер полей в хранилище](#Средний-размер-хранилища)

1. Регистрация: \
   Запрос: **-**
      > 225 байт пользователь * 1 RPS - пренебрежимо мало

   Ответ: **-**
      > 225 байт пользователь * 1 RPS - пренебрежимо мало
2. Авторизация по паролю: \
   Запрос: **-**
      > (25 почта + 128 пароль) байт * 10 - пренебрежимо мало

   Ответ: **-**
      > 225 байт пользователь * 10 RPS - пренебрежимо мало
3. Авторизация по сессии: \
   Запрос: **0,04 Гбит/с**
      > (16 байт кука + 2 байта id пользователя) * 283 467 RPS = 0,04 Гбит/с

   Ответ: **0,04 Гбит/с**
      > (16 байт кука + 2 байта id пользователя) * 283 467 RPS = 0,04 Гбит/с
4. Отправка сообщения: \
   Текстовое: \
      Запрос: ****
         > (100 байт текст + 2 байта чат) * 158 680 RPS = 

      Ответ: ****
         > (2 байт id cообщения  + 8 байт время) * 158 680 RPS =

   Голосовое: \
      Запрос: ****
         > (2 байт чат + 1920 кбит гс) * 14 930 RPS 

      Ответ: ****
         > (2 байт id сообщения  + 8 байт время) * 14 930  RPS

   С вложением: \
      Запрос: ****
         > (2 байт чат + 2 мб вложение) * 3 430 RPS

      Ответ: ****
         > (2 байт id сообщения  + 8 байт время) *  3 430 RPS =
5. Изменение сообщения: \
   Запрос: ****
      > (100 байт текст + 2 байта чат + 2 байт id сообщения) * 16 009 RPS =

   Ответ: ****
      > (2 байт id сообщения + 8 байт время) * 16 009 RPS =
6. Удаление сообщения: \
   Запрос: ****
      > ( 2 байта чат + 2 байт id сообщения) * 1 715 RPS

   Ответ: ****
      > 2 байт id сообщения * 1 715 RPS =
7. Получение сообщения: \
   Текстовое: \
      Запрос: ****
         > При
         > (100 байт текст + 2 байта чат) *  RPS = 

      Ответ: ****
         > (2 байт id cообщения  + 8 байт время) * 158 680 RPS =

   Голосовое: \
      Запрос: ****
         > (2 байт чат + 1920 кбит гс) * 14 930 RPS 

      Ответ: ****
         > (2 байт id сообщения  + 8 байт время) * 14 930  RPS

   С вложением: \
      Запрос: ****
         > (2 байт чат + 2 мб вложение) * 3 430 RPS

      Ответ: ****
         > (2 байт id сообщения  + 8 байт время) *  3 430 RPS =
         
8. Работа с сообщениями:
   
 
   Создание: *1,27 Гбит/с*
   > 1 кб * 158680 RPS = 1,27 Гбит/с

   Изменение: *0,13 Гбит/с*
   > 1 кб * 16009 RPS = 0,13 Гбит/с

   Получение: *6,4 Гбит/с*
   > 10 сообщейний в пачке * 1 кб * 80 046 RPS = 6,4 Гбит/с
5. Работа с голосовыми сообщениями: 

   Создание: *28,7 Гбит/с*
   > 1920 кбит * 14930 RPS = 28,7 Гбит/с

   Получение: *104,3 Гбит/с*
   > 1920 кбит * 54 317 RPS = 104,3 Гбит/с
6. Работа с вложениями в сообщениях:

   Загрузка: *27,44 Гбит/с*
   > 1 мб * 3430 RPS = 27,44 Гбит/с

   Получение: *96,1 Гбит/с*
   > 1 мб * 12006 RPS = 96,1 Гбит/с

## Физическая схема базы данных
![физическая схема бд](/imgs/db_scheme_phys.png)

### PostgreSQL
Хранение данных о `пользователях`, `сообщениях` и `чатах`. 

> Поддерживает обширный функционал, инструменты шардинга, а также популярна (а следовательно имеет хорошую поддержку).

Предусмотрим **репликацию** данных. Из-за большого объёма выберем схему master-slave. Master будет принимать операции записи, Slave - чтение. 

#### Шардирование и индексы
1. Таблица пользователей `users`
   Так как RPS авторизации (по полям `email` `passwd_hash`), поиска пользователей (`first_name` `last_name`) невелик, количество пользователей записей с частотой 1 RPS, а чтение данных происходит по `id` при каждом заходе в чат, то имеет смысл **шардирование по `id`** для уменьшения количества записей в таблице.

   Используем **индексы** для авторизации по составному ключу `email` + `passwd_hash` и **индексы** для поиска пользователей по ключам `lower(first_name)`, `lower(last_name)`, `(lower(first_name), lower(last_name))`. 

2. Таблица чатов `chats`
   Шардирование применять нецелесообразно. 
   Используем индексы по ключам `user_1_id`, `user_2_id` 
3. Таблица сообщений `messages`
   Сообщения накапливаются в хронологическом порядке по полю `create_date`. 
   Каждое сообщение привязано к соответствующему чату `chats` по полю `chat_id`.
   RPS на создание записей около 180 тыс. 
   RPS на поиск сообщений по `chat_id` 46 тыс.
   Стандартый сценарий использования - проверка последних сообщений, скроллинг вверх для просматривания более старых сообщений происходит гораздо реже.
   Выбираем **шардирование** по составному ключу `create_date` + `chat_id`

### Tarantool
Хранение `сессий` пользователей

> Tarantool - *in-memory* база данных, следовательно доступ к записям осуществляется со значительно большей скоростью. Поддерживает репликацию, позволяет горизонтально масштабироваться и предоставляет технологию Tarantool Cartrige и роутер, которые позволяют создать кластер и настроить роутинг быстро, удобно  и надёжно.

Так как RPS на чтение велик (проверка авторизации при каждом обращении к бэкэнду), а на запись относительно мал, то используем репликацию master-slave, где master будет отвечать за запись и чтение, а slave только за чтение. 

Так как поиск в таблице осуществляется по полю `user_id`, создадим для него индекс.

###  S3 хранилище
S3 хранилище для `аватарок`, `вложений в сообщениях` и `голосовых сообщений`. Данные имеют большой объём, поэтому выбираем технологию S3 для их хранения и быстрого доступа. Целесообразно воспользоваться услугами облачных провайдеров по типу **Yandex Object Storage** (предпочтительнее по географическому расположению) или **Amazon S3**.

## Выбор технологий

| Технология            | Область примененения | Мотивация                                                                                                                                                                                                                                                                                                                                                                                         |
| --------------------- | -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| React                 | Frontend             | Фреймворк, позволяющий удобно вести разработку, разделяя код на модули                                                                                                                                                                                                                                                                                                                            |
| Typescript            | Frontend             | Статическая типизация, упрощает процесс разработки, позволяя ловить баги на моменте "сборки"                                                                                                                                                                                                                                                                                                      |
| Redux                 | Frontend             | Хранилище состояний. Уменьшение связей между компонентами путём введения глобаьного состояния приложения                                                                                                                                                                                                                                                                                          |
| Webpack + babel       | Fronend              | Сборка приложения, сжатие кода для уменьшения размера файла при передачи клиенту                                                                                                                                                                                                                                                                                                                  |
| Go                    | Backend              | Многопоточность и асинхронность из коробки, большое количество библиотек для работы по http (роутеры, парсеры и т.п.)                                                                                                                                                                                                                                                                             |
| PostrgeSQL            | Backend              | Реляционная БД с возможностью оптимизации и ускорения при хранении больших объёмов данных. Популярна, большое комьюнити, хорошая поддержка                                                                                                                                                                                                                                                        |
| Tarantool             | Backend              | in-memory БД для хранения сессий пользователей. Обладает очень малым времени обработки запроса на чтение и запись, популярна, большое комьюнити. Шардирование, репликация, балансировка, роутинг.                                                                                                                                                                                                 |
| Yandex Object Storage | Backend              | S3 хранилище для медиафайлов (аватарки, вложения в сообщениях, голосовые сообщения). Приемлимая стоимость, удобное расположение дата-центров. Отличная поддержка и работа с большими объёмами данных                                                                                                                                                                                              |
| Prometheus            | Мониторинг           | Сборка метрик с приложения для анализа работы, распределения нагрузки и поиска узких мест                                                                                                                                                                                                                                                                                                         |
| Graphana              | Мониторинг           | Удобный инструмент для работы с метриками путём построения наглядных дашбордов. Очень гибкая настройка под любые нужды                                                                                                                                                                                                                                                                            |
| Nginx                 | Frontend             | L7 балансировщик, отдача статики, кеширование                                                                                                                                                                                                                                                                                                                                                     |
| Swift + SwiftUI       | Mobile IOS           | Исследования показывают, что число пользователей с мобильных устройств с каждым годом растёт и вытесняет ПК. IOS- одна из самых популярных ОС в мире, в том числе и СНГ, поэтому наличие мобильного приложения де-факто стандарт. Swift наиболее распространенный и поддерживаемый ЯП для IOS устройств. RxSwift вносит реактивность, что позволяет объединять архитектуры Пк версии и IOS версии |
| Kotlin + RxKotlin     | Mobile Android       | Android - самая популярная ОС в мире. Наличие мобильного приложения под Android позвляет дать комфортное использование продукта большому числа людей. RxKotlin позволяет писать рективные приложения.                                                                                                                                                                                             |

## Схема проекта
![схема проекта](/imgs/app_scheme.png)

Архитектура: Микросервисная \
Балансировка: Сетевой + транспортный + прикладной уровень

Пояснения к схеме: 

Пользователь обращается к DNS серверу для разрешения имени хоста, получает один из ip адресов веб-сервера. Отправляет свой запрос на этот веб-сервер. Веб-сервер отдаёт статику и перенаправляет все запросы к api на один из кластеров с главным сервисов в зависимости от устройства пользователя (web version или mobile).

В главном приложении (web gateway или mobile gateway) стоит L7 балансировщик, который кидает запрос на один из бэкэндов с основным приложением(которое умеет общаться с остальными микросервисами) из пулла бэкэндов.

Далее происходит аутентификация пользователя по сессии (обращение к микросервису Authorization service) или по паролю (обращение к User service) с последующем создании сессии.

После в зависимости от запроса (запрос на получение юзера, отправку сообщения и тп). Основное приложение обращается к микросервисам User service,  Messenger service и обрабатывает запрос. Для получение картинок сервис ходит в Yandex Object Storage.

После обработки запрос к api пользователю возвращется результат. 

Каждый микросервис балансирует нагрузку на уровне L7 и перенаправляет запрос на один из бэкэндов из пула. 

Так как бэкэнды написаны на Go, то очень удобно для общения микросервисов использовать gRPC, который под капотом имеет HTTP2. gRPC позволяет "вызывать" функции с удаленного микросервиса.

База данных Tarantool имеет свой роутер Tarantool Cartrige, который умеет делить запросы на Master и Slave, поддерживать согласованность в репликах. В случае падения одной из реплик, запросы направляются на другу.

База данных Postgres имеет модуль pgBauncer, который направляет запросы на соответствующие шарды и их реплики. В случае падения одной из нод, запросы направляются на резервную.

Запросы на получение картинок обращаются к облачному S3 хранилищу Yandex Object Storage, который из соответствующих бакетов возвращает данные.

## Список серверов

> Так как по данным из открытых источников удалось определить только среднесуточный трафик и RPS, а в действительности нагрузка на сервисы распределяется неравномерно и имеет пиковые часы, необходимо предусмотреть запас по ресурсам. Для этого будем брать среднесуточный RPS на трафик в 2 раза больший, чем вычисленный выше.

### Веб-серверы
Выбрали nginx, примем RPS на 1 ядро по https с учётом оптимизации конфигураций 1 тыс. 
Для хранения статики 1 ssd на 128 Гб

### Сервис пользователя
Сервис написан на Golang, примем, с учетом использования многопоточности, RPS на одно ядро равным 2 тыс. 
> RPS который должен поддерживаться:
> | Запрос                                         | RPS    |
> | ---------------------------------------------- | ------ |
> | Регистрация                                    | 1      |
> | Авторизация по паролю                          | 10     |
> | Поиск пользователя                             | 35     |
> | Получение данных при получении сообщений       | 80 046 |
> | Получение данных при получении списка диалогов | 8 576  |

Итого необходиомо поддержать: **177 336 RPS**
> 2 * 88 668 = 177 336 RPS с учётом пиковых нагрузок

Необходимое количество ядер: **88**
> 177 336 / 2 000 = 88 

Суммарный трафик: **0,8 Гбит / с**
> 177 336 RPS * (2 + 64 + 64 + 256 + 128 + 40 + 16) байт = 0,8 Гбит / с

Упираемся в CPU. Если взять сервер с 32 CPU, то потребуется **4 сервера**
> 88 / 32 = 4 сервера

Однако в случае падения машины, трафик поделится на 3 оставшиеся и нагрузка на CPU будет 92%
> 177 336 * 100% / (2 000 * 32 * 3) = 92 %

Увеличиваем количество серверов до 5 и аналогичными расчётами получаем нагрузку 70% на CPU в случае падения машины.   

| Количество серверов | RAM | CPU | SSD (Gb) | Network, Gbit / s |
| ------------------- | --- | --- | -------- | ----------------- |
| 5                   | 32  | 32  | 32       | 1                 |

### Сервис сообщений
Сервис написан на Golang, примем, с учетом использования многопоточности, RPS на одно ядро равным 2 тыс. 
> RPS который должен поддерживаться:
> | Запрос                               | RPS     |
> | ------------------------------------ | :------ |
> | Создание чата                        | 35      |
> | Удаление чата                        | 0       |
> | Получение списка чатов  пользователя | 8 576   |
> | Отправка текстового сообщения        | 158 680 |
> | Изменение сообщения                  | 16 009  |
> | Удаление сообщений                   | 1 715   |
> | Получение списка сообщений           | 80 046  |

Итого необходиомо поддержать: **530 122 RPS**
> 2 * 265 061 RPS = 530 122 RPS с учетом пиковых нагрузок.

Необходимое количество ядер: **264**
> 530 122 / 2 000 = 264

Суммарный трафик: **15,6 Гбит / с**
> 2 * (1,27 + 0,13 + 6,4) = 15.6 Гбит/с

Выбираем сервер с 32 CPU и 1 Gbit/s сетью. \
Необходимое количество серверов: **16**
> По CPU: 264 / 32 = 9 \
> По сети: 15,6 / 1 = 16  

В случае падения машины, трафик поделится на 15 оставшиеся и нагрузка на сеть будет 104%
> 15,6 Гбит / с * 100% / (1 Гбит/с * 15) = 104 %

Увеличиваем количество серверов до 22 и аналогичными расчётами получаем нагрузку 74% на сеть в случае падения машины.   

| Количество серверов | RAM | CPU | SSD (Gb) | Network, Gbit / s |
| ------------------- | --- | --- | -------- | ----------------- |
| 22                  | 32  | 32  | 32       | 1                 |

### Gateway
По информации с [^9] только 29% запросов приходятся на ПК, остальные на мобильные устройства
Сервис написан на Golang, примем, с учетом использования многопоточности, RPS на одно ядро равным 2 тыс. 
> RPS который должен поддерживаться:
> | Запрос                               | RPS     |
> | ------------------------------------ | :------ |
> | Регистрация                          | 1       |
> | Авторизация по данным уч. записи     | 10      |
> | Создание чата                        | 35      |
> | Удаление чата                        | 0       |
> | Получение списка чатов  пользователя | 8 576   |
> | Отправка текстового сообщения        | 158 680 |
> | Отправка голосового сообщения        | 14 930  |
> | Отправка вложений в сообщения        | 3 430   |
> | Изменение сообщения                  | 16 009  |
> | Удаление сообщений                   | 1 715   |
> | Получение списка сообщений           | 80 046  |
> | Получение голосовых сообщений        | 54 317  |
> | Получение вложений                   | 12 006  |
> | Поиск пользователя                   | 35      |

Итого необходиомо поддержать: **556 000 RPS**
> 2 * 278 000 RPS = 556 000 RPS с учетом пиковых нагрузок.

#### Web
Итого необходиомо поддержать: **161 240 RPS**
> 0,29 *  556 000 = 161 240 RPS.

Необходимое количество ядер: **82** 
> 161 240 / 2 000 = 82 

Суммарный трафик: **152 Гбит / с**
> 2 * 0,29 * (0,15 + 0,04 + 1,27 + 0,13 + 6,4 + 28,7 + 104,3 + 27,44 + 96,1) = 2 * 0,29 * 264,53 = 152 Гбит / с

Выбираем сервер с 8 CPU и 10 Gbit/s сетью.
Необходимое количество серверов: **16**
> По CPU: 82 / 8 = 11 \
> По сети: 152 / 10 = 16  

В случае падения машины, трафик поделится на 15 оставшиеся и нагрузка на сеть будет 101%
> 152 Гбит / с * 100% / (10 Гбит/с * 15) = 101 %

Увеличиваем количество серверов до 22 и аналогичными расчётами получаем нагрузку 72% на сеть в случае падения машины.  

| Количество серверов | RAM | CPU | SSD (Gb) | Network, Gbit / s |
| ------------------- | --- | --- | -------- | ----------------- |
| 22                  | 64  | 8   | 32       | 10                |

#### Mobile
Итого необходиомо поддержать: **394 760 RPS**
> 0,71 * 556 000 = 394 760 RPS

Необходимое количество ядер: **200** 
> 394 760 / 2 000 = 200 

Суммарный трафик: **376 Гбит/с**
> 2 * 0,71 * (0,15 + 0,04 + 1,27 + 0,13 + 6,4 + 28,7 + 104,3 + 27,44 + 96,1) = 2 * 0,71 * 264,53 = 376 Гбит / с

Выбираем сервер с 8 CPU и 10 Gbit/s сетью.
Необходимое количество серверов: **38**
> По CPU: 200 / 8 = 25 \
> По сети: 376 / 10 = 38  

В случае падения машины, трафик поделится на 37 оставшиеся и нагрузка на сеть будет 101%
> 376 Гбит / с * 100% / (10 Гбит/с * 37) = 101 %

Увеличиваем количество серверов до 50 и аналогичными расчётами получаем нагрузку 76% на сеть в случае падения машины.  

| Количество серверов | RAM | CPU | SSD (Gb) | Network, Gbit / s |
| ------------------- | --- | --- | -------- | ----------------- |
| 50                  | 64  | 8   | 32       | 10                |

## Tarantool 
> RPS по типам:
> | Запрос                | RPS     |
> | --------------------- | ------- |
> | Авторизация по сессии | 283 467 |

Необходимо поддержать RPS: **566 934**
> 2 * 283 467 = 566 934 RPS с учетом пиковых нагрузок 

RPS на однин инстанс около 100 тыс \
Tarantool гарантирует атомарность, поэтому рабочий процесс на одном ядре. Всего нужно 3 ядра 

Сумарный размер хранимых данных в ОЗУ: **11 Гб** \
Сумарный размер хранимых данных на ssd: **21 Гб** \
Трафик: 2 * 0,04 Гбит/с = **0,08 Гбит/с**

Выбираем сервер с 4 CPU, 64 Gb RAM и 1 Gbit / s Network

Выбрали схему Master -> N * Slaves. Master отвечает за операции записи, RPS которых невелик, и репликацию данных, а N штук Slaves обрабатывают операции чтения.

Потребуется **2 Master и 6 Slave**, предусмотрели отказ master'а. \
В случае отказа одного из Slave, останется 7 инстансов, т.е. RPS на один составит 566 934 RPS / 7 = 81 000 RPS на реплику, не выходим за границы нагрузки на инстанс.

| Количество серверов    | RAM | CPU | SSD (Gb) | Network, Gbit / s |
| ---------------------- | --- | --- | -------- | ----------------- |
| 2 (Master) + 6 (Slave) | 64  | 8   | 64       | 1                 |

## PostgreSQL users
Размер данных: **53 Гб** \
Эффективная работа индексов достигается большим количеством ОЗУ \
Необходиомо поддержать: **177 336 RPS**
> 2 * 88 668 RPS = 177 336 с учетом пиков нагрузки.

Трафик: **0.8 Гбит / с**
> 2 * (2 + 64 + 64 + 256 + 128 + 40 + 16) байт * 88 668 RPS = 0,8 Гбит / с

Возьмем сервер 32 CPU, 256 Gb RAM, 1 Gbit/s Net

Примем количество одновременно обрабатываемых запросов на ядро равным **8**. Итого **256** одновременно обрабатываемых запросов. \
Примем продолжительность одного запроса **1 / 200 сек**. \
Тогда один сервер вытянет: 200 * 256 = **51 200 RPS** 

Выбрали схему репликации Master + Slave, оба отвечают за чтение, а Master также за запись. Запросы шардируются по `id`.

Примем количество серверов равным 6: **3 Master и 3 Slave**

В случае выхода из строя одного из серверов, нагрузка на оставшиеся составит 177 336 / 5 = 35 тыс RPS, что не превышает предел нагрузки 

| Количество серверов     | RAM | CPU | SSD (Gb) | Network, Gbit / s |
| ----------------------- | --- | --- | -------- | ----------------- |
| 3 (Masеter) + 3 (Slave) | 256 | 32  | 128      | 1                 |

## PostgreSQL messenger

### Чаты 
Размер данных **22,38 Гб** \
Эффективная работа индексов достигается большим количеством ОЗУ \
Необходиомо поддержать: **17 152 RPS**
> 2 * 8 576 RPS = 17 152 RPS с учетом пиков нагрузки

Трафик: **32.8 Мбит/с**
> 40 чатов * (2 + 2 + 2) байт * 17 152 RPS = 32.8 Мбит / с

Возьмем сервер 32 CPU, 256 Gb RAM, 1 Gbit/s Net

Примем количество одновременно обрабатываемых запросов на ядро равным **8**. Итого **256** одновременно обрабатываемых запросов. \
Примем продолжительность одного запроса **1 / 200 сек**. \
Тогда один сервер вытянет: 200 * 256 = **51 200 RPS** 

Выбрали схему репликации Master + Slave, оба отвечают за чтение, а Master также за запись.

Примем количество серверов равным 2: **1 Master и 1 Slave**

В случае выхода из строя одного из серверов, нагрузка на оставшиеся составит 17 152 / 1 = 18 тыс RPS, что не превышает предел нагрузки на одну машину.

| Количество серверов | RAM | CPU | SSD (Gb) | Network, Mbit / s |
| ------------------- | --- | --- | -------- | ----------------- |
| 2                   | 128 | 16  | 64       | 100               |

### Сообщения
Размер данных за 3 года **13 981,5 Тб** \
Посуточный размер данных **1725 Гб / день** \
Эффективная работа индексов достигается большим количеством ОЗУ

> Запросы:
> | Запрос                        | RPS     |
> | ----------------------------- | :------ |
> | Отправка текстового сообщения | 158 680 |
> | Изменение сообщения           | 16 009  |
> | Удаление сообщений            | 1 715   |
> | Получение списка сообщений    | 80 046  |

Необходимо поддержать: **512 900 RPS**
> 2 * (158 680 + 16 009 + 1 715 + 80 046) =  512 900 RPS с учётом пиков 

Трафик: **15,6 Гбит / с** 
> 2 * (6,4 + 1,27 + 0,13) = 15,6 Гбит / с  с учетом пиковых нагрузок

Примем количество одновременно обрабатываемых запросов на ядро равным **8**. Итого **8 * CPU** одновременно обрабатываемых запросов. \
Примем продолжительность одного запроса **1 / 200 сек**. \
Тогда один сервер вытянет: **200 * 8 * CPU RPS**

Выбираем сервер 32 CPU, 128 RAM, 24 * 2 Tb SSD, 1 Gbit/s Net

Необходимое количество серверов: **292** \
> По CPU:  512 900 / (200 * 8 * 32) = 11 \
> По сети: 15,6 / 1 = 16  \
> По хранилищу: 13 981,5 / (2 * 24) = 292

Выбираем сервер 4 CPU, 128 RAM, 24 * 2 Tb SSD, 1 Gbit/s Net
Необходимое количество серверов: **292** \
> По CPU:  512 900 / (200 * 8 * 4) = 81 \
> По сети: 15,6 / 1 = 16  \
> По хранилищу: 13 981,5 / (2 * 24) = 292

Выбрали схему репликации Master + Slave, оба отвечают за чтение, а Master также за запись.

Потребуется 600 серверов: **300 Master и 300 Slave**. База данных шардируется по составному ключу `chat_id` + `create_date` между 300 Master серверами. В случае выхода из строя Master его функции принимает Slave 

| Количество серверов        | RAM | CPU | SSD (Tb) | Network, Gbit / s |
| -------------------------- | --- | --- | -------- | ----------------- |
| 300 (Master) + 300 (Slave) | 128 | 8   | 2 * 24   | 1                 |

## Список литературы
[^1]: [Исследование соцсетей и мессенджеров](https://vk.com/press/mediascope-october-2022)

[^2]: [Статистика ВК за 1 кв. 2022 г.](https://habr.com/ru/news/t/663492/)

[^3]: [Статистика Вконтакте](https://3dnews.ru/1061274/auditoriya-vkontakte-v-rossii-virosla-do-725-mln-polzovateley-v-2021-godu)

[^4]: [География Вконтакте](https://yandex.ru/images/search?pos=4&img_url=http%3A%2F%2Fmyslide.ru%2Fdocuments_4%2Ff4c31844a42fc2099f9afe5bc0b49186%2Fimg23.jpg&text=%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B0%D1%83%D0%B4%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B8%20%D0%B2%D0%BA%20%D0%BF%D0%BE%20%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B0%D0%BC&lr=213&rpt=simage&source=serp)

[^5]: [Количество созданных чатов за день](https://team.vk.company/vacancy/30137/)

[^6]: [Длина имени и фамилии](https://ch-pik.ru/kakova-sredniaia-dlina-familii)

[^7]: [Посещаемость мессенджеров за день](https://www.cnews.ru/news/top/2018-02-28_whatsapp_stal_samym_populyarnym_messendzheram_v)

[^8]: [Распределении аудитории по мессенджерам в СНГ](https://wciom.ru/analytical-reviews/analiticheskii-obzor/rossiiskaja-auditorija-socialnykh-setei-i-messendzherov-izmenenija-na-fone-specoperacii)

[^9]: [Процент пользователей мобильных устройств](https://seo-aspirant.ru/mobilnye-ustrojstva-protiv-kompyuterov-2020)